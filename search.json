[{"title":"Redis基础数据结构之简单动态字符串","url":"/2020/09/27/Redis基础数据结构之简单动态字符串/","content":"\n该系列主要是阅读了《redis设计与实现》后的一些随笔，供自己回味，也供大家参考。本文主要介绍Redis基础数据结构之简单动态字符串，这是Redis最基本的数据结构，许多其他的数据结构都会基于其进行构建，同时这也是我觉得设计得比较有趣的数据结构。\n\n<!-- more -->\n\n## 概述\n\n- Redis底层是使用C语言实现，但是在使用字符串时没有直接使用C语言传统的字符串，而是使用的一种自己构建的名为简单动态字符串（simple dynamic string，简称SDS）的抽象类型，并把SDS作为Redis字符串的默认实现。\n\n- C语言传统字符串被作为字符串字面量用在一些无须对字符串做修改的地方，比如打印日志：\n\n  ```c\n  redisLog(REDIS_WARNING, \"Redis is now ready to exit, bye bye...\")\n  ```\n\n- SDS在Redis中的主要作用是用来保存数据库中的字符串，同时它还被用作缓冲区（buffer）\n\n  - AOF模块中的AOF缓冲区\n  - 客户端状态中的输入缓冲区\n\n## SDS的定义\n\n#### 1. 源代码展示\n\n```c\n// sds定义了三个属性\nstruct sdshdr {\n    // 记录buf数组中已经使用是字节的数量，其实就是目前sds所保存的字符串的长度\n    int len;\n    // 记录buf数组中未使用字节的数量\n    int free;\n    // 字节数组，用来保存字符串\n    char buf[];\n}\n```\n\n#### 2. 图示讲解\n\n[![sds图示](https://s3.ax1x.com/2020/12/23/r6w861.png)](https://imgchr.com/i/r6w861)\n\n> 图中展示了一个简单的sds结构\n\n- free 为0表示sds剩余容量是0字节，即没有分配未使用的空间\n- len 为5表示sds保存了5字节长度的字符串。图示中实际占用6个字节的长度，是因为C语言的字符串以```\"\\0\"```（即ASCII码为0的空字符）标识结尾，而sds结构也也沿用了C语言这个设计，但是```\"\\0\"```是不计算在sds长度之内的，并且将```\"\\0\"```添加到字符串结尾的操作由sds函数自动完成，属于无感知操作\n- buf 是一个char类型的字符串数组，图示为数组用5个字节保存了字符串```\"Redis\"```这5个字符，并且用一个字节保存了```\"\\0\"```这个字符\n\n[![sds图示-带free](https://s3.ax1x.com/2020/12/23/r6w3lR.png)](https://imgchr.com/i/r6w3lR)\n\n- 图示的sds结构free 为3，即表示还有3个字节的空余空间可以使用\n- 这里空余空间用空格代替\n\n\n\n## SDS与C字符串的区别\n\n#### 1. 常数复杂度获取字符串长度\n\n- C字符串没有记录自身的长度信息，想要知道字符串的长度，只能通过遍历整个字符串计数，直到遇到```\"\\0\"```停止计数。很明显这样的操作复杂度为O(N)\n- sds通过len 属性记录sds字符串的长度，想要获取sds字符串的长度信息直接读取len 属性即可，这样复杂度就降到了O(1)，即使多次对长字符串执行```STRLEN```命令也不会产生性能瓶颈。设置和更新sds长度都是由sds的API在执行时自动完成的，使用sds时无需进行任何手动修改长度的工作。\n\n#### 2. 杜绝缓冲区溢出\n\n##### 2.1 什么叫缓冲区溢出\n\n> 该问题同样是由C字符串不记录自身长度引入的，下面举个例子说明\n\n- C字符串里面有个字符串拼接函数```strcat```，类似于Java中```\"+\"```在字符串中的作用，将给定字符串拼接到目标字符串的末尾。因为C字符串不记录自身长度，如果目标字符串分配的长度不足以存放拼接后的字符串，并且拼接之前也并未对目标字符串进行长度重新分配，一旦执行```strcat```函数后，则会发生缓冲区溢出\n\n- 文字解释起来可能有点绕，下面使用图示说明\n\n  - 假定有两个在内存中紧邻的C字符串 s1和 s2，s1 = \"redis\"，s2 = \"mongodb\"，如下图所示：\n    [![相邻C字符串](https://s3.ax1x.com/2020/12/23/r6wKkF.png)](https://imgchr.com/i/r6wKkF)\n  - 调用函数：\n\n  ```c\n  strcat(s1, \"cluster\")\n  ```\n\n  改变 s1的内容为：\"redis cluster\"，但是调用函数前如果未对 s1分配足够的内存，s1的内容就会溢出到 s2的内存空间中，导致 s2的内容被修改\n\n  [![相邻C字符串-缓冲区溢出](https://s3.ax1x.com/2020/12/23/r6wGOx.png)](https://imgchr.com/i/r6wGOx)\n\n\n\n##### 2.2 SDS的解决策略\n\n- 其实很简单，既然直接拼接有可能会产生缓冲区溢出，那就在拼接之前检查一下嘛。当SDS需要修改时，SDS的API会对SDS的空间进行确认，看是否满足修改所需的空间要求，如果不满足，SDS的API会自动扩展SDS的空间来满足修改，然后再执行修改的操作。所以SDS既不需要手动修改SDS的空间大小，也不会产生缓冲区溢出的问题\n- 举个示例：SDS的API中有一个```sdscat```函数，将一个C字符串拼接到目标SDS所保存的字符串后面，在拼接之前，```sdscat```会检查SDS的剩余空间是否足够，如果不够就先扩展SDS的空间，然后进行拼接。至于扩展策略在下面的内容中介绍\n\n##### 2.3 自己的理解\n\n看到这第一感觉 SDS有点类似于Java中集合的味道。另外Java的字符串中没有缓冲区内存溢出的概念，Java字符串是基于字符数组实现的，JVM对数组会进行边界检查，感兴趣的具体可以网上查阅\n\n#### 3. 减少修改字符串时带来的内存重分配次数\n\nC字符串不记录自身的长度，一个 N 个字符长度的C字符串，底层实现是 N+1 个字符长的数组（多的一个字符空间用来保存空字符```\"\\0\"```），而数组一旦创建出来长度就是固定的，所以每次增长或者缩短一个C字符串，则需要对保存这个C字符串的数组进行一次重新分配内存：\n\n- 如果是增长字符串的操作，例如拼接（append）操作，那么在执行这个操作之前，程序要先通过内存重分配来扩展底层数组的大小——如果没有这一步就会产生缓冲区溢出\n- 如果是缩短字符串的操作，例如截断（trim）操作，那么在执行这个操作之后，程序要先通过内存重分配来释放字符串不再使用的那部分空间——如果没有这一步就会产生内存泄漏\n\n内存重分配涉及复杂的算法，并且有可能需要执行系统级别的调用，通常来说是一个比较耗时的操作，这对于追求性能的 Redis 数据库来说是致命的，所以 SDS 引入一个未使用空间的概念，即 free 属性。通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略：\n\n##### 3.1 空间预分配\n\n这是用来优化SDS的字符串增长操作。在SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展时，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用的空间\n\n以下为额外分配的未使用空间的公式：\n\n- 如果对SDS进行修改后，SDS的长度（也就是 len 属性）小于1MB，则程序会分配和 len属性相同长度的剩余空间，也就是说 len属性和 free属性的值相同。例如进行修改之后 len属性为16，则程序会将free属性也置为16，此时 buf数组的实际长度为 16 + 16 + 1 = 33（1为结尾的空字符）\n- 如果对SDS进行修改后，SDS的长度大于等于1MB，则程序会分配 1MB 的剩余空间。例如在进行修改后 len 变为 5MB，则程序会将 free属性置为 1MB，次数buf数组的实际长度为 5MB + 1MB + 1byte\n\n1. 正是因为空间预分配策略，在扩展SDS之前，SDS的API会先检查剩余空间是否足够，如果足够的话，API就会直接使用剩余空间，无需进行内存重分配\n2. 通过这种策略，SDS将连续增长N次字符串所需的内存重分配次数从必定N次减少到最多N次\n\n##### 3.2 惰性空间释放\n\n这是用来优化SDS的字符串缩短操作。当SDS的API需要缩短SDS所保存的字符串时，程序不会立即使用内存重分配来回收缩短后多出的内存字节，而是用 free 字段将这些字节的数量记录起来，等待将来使用\n\n- 图示举例\n\n1. 有一个SDS结构s如下图：\n\n[![惰性空间释放](https://s3.ax1x.com/2020/12/23/r6wQfJ.png)](https://imgchr.com/i/r6wQfJ)\n\n2. 执行函数\n\n```c\n// 函数的作用：移除sds字符串中所有的\"x\"\nsdstrim(s, \"x\")\n```\n\n3. 修改后的SDS结构如下图：\n\n[![惰性空间释放-修改后](https://s3.ax1x.com/2020/12/23/r6w1p9.png)](https://imgchr.com/i/r6w1p9)\n\n执行```sdstrim```函数后多出的4个空间并没有立即释放，而是放入 free属性中，作为未使用空间保留在SDS结构里。如果将来要进行增长操作，并且增长的字符串小于 free 属性的4字节，就可以不用就行扩展操作直接增长\n\n- 通过惰性空间释放的策略，SDS避免了缩短字符串时所需要的内存重分配操作，并同时为将来可能发生的增长操作提供了优化，正是一石二鸟之计，妙哉\n- 当然SDS也提供了真正释放SDS未使用空间的API，让我们在有需要的时候真正的释放，不用担心惰性空间释放策略造成的内存浪费\n\n#### 4. 二进制安全\n\n- C字符串中的字符必须要符合某种编码，并且除了末尾之外不能包含空字符，否则会被程序误以为是字符串的结尾。这种限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件等二进制数据\n- 数据库需要保存各种类型的数据，为了确保Redis 可以适用不通的场景，SDS的API都是二进制安全的，所有SDS的API都会以处理二进制的方式来处理SDS保存在buf数组中的数据，程序不会对里面的数据做任何限制、过滤、假设，数据的写入时是什么样，读取时就是什么样\n- 例如 SDS 就算是保存包含多个空字符的字符串也没有问题，因为SDS是依赖 len 属性的值而不是空字符来判断字符串的结尾\n\n#### 5. 兼容部分C字符串函数\n\n- 由于 SDS 遵循C字符串以空字符结尾的惯例，SDS的API都会在SDS保存的数据末尾设置空字符，并且buf数组分配空间时也会多分配一个字节来容纳这个空字符，这都是为了那些保存文本数据的SDS可以重用一部分C字符串的函数\n- 例如：有一个保存文本数据的SDS结构s，就可以用```strcasecmp```函数来对比SDS保存的字符串和另一个C字符串\n\n```c\nstrcasecmp(s -> buf, \"test\");\n```\n\n- 重用C字符串的函数库，避免了重复造轮子，避免了不必要的代码重复\n\n\n\n## SDS主要API展示\n\n| 函数        | 作用                                                         | 时间复杂度                            |\n| ----------- | ------------------------------------------------------------ | ------------------------------------- |\n| sdsnew      | 创建一个包含给定字符串的sds                                  | O(N)，N为给定C字符串的长度            |\n| sdsempty    | 创建一个不包含任何内容的空sds                                | O(1)                                  |\n| sdsfree     | 释放给定的sds                                                | O(N)，N为被释放sds的长度              |\n| sdslen      | 返回sds的已使用空间字节数                                    | 直接读取len属性，O(1)                 |\n| sdsavail    | 返回sds的未使用空间字节数                                    | 直接读取free属性，O(1)                |\n| sdsdup      | 创建一个给定sds的副本（copy）                                | O(N)，N为给定sds的长度                |\n| sdsclear    | 清空sds保存的字符串内容                                      | 惰性空间释放策略，复杂度为O(1)        |\n| sdscat      | 将给定C字符串拼接到sds字符串的末尾                           | O(N)，N为被拼接C字符串的长度          |\n| sdscatsds   | 将给定sds字符串拼接到另一个sds字符串的末尾                   | O(N)，N为被拼接sds字符串的长度        |\n| sdscpy      | 将给定的C字符串复制到sds里面，覆盖sds原有的字符串            | O(N)，N为被复制C字符串的长度          |\n| sdsgrowzero | 用空字符将sds扩展到给定长度                                  | O(N)，N为扩展新增的字节数             |\n| sdsrange    | 保留sds给定区间内的数据，不再区间内的数据被覆盖或清除        | O(N)，N为保留数据的字节数             |\n| sdstrim     | 接受一个sds和一个C字符串作为参数，从sds中移除所有在C字符串中出现过的字符 | O(N*N)，N为给定C字符串的长度          |\n| sdscmp      | 对比两个sds字符串是否相同                                    | O(N)，N为两个sds中较短的那个sds的长度 |\n\n\n\n**参考资料：《Redis设计于实现（第二版）》—黄健宏**","tags":["Redis"],"categories":["Redis"]},{"title":"Java之NIO初探","url":"/2020/09/15/Java之NIO初探/","content":"\n这篇文章是学习了NIO之后的总结，结合了网上的博客和资料\n简述：在软件系统中，由于I/O的速度远比内存速度慢，所以I/O很容易成为系统的瓶颈。何为NIO，其实就是New IO的简称，与旧式基于流的I/O相对。\n<!-- more -->\n\n## NIO与IO的区别，NIO的特性\n\n1. NIO以块（Block）为基本单位处理数据，而IO是以最基础的字节流的形式去写入和读出。由于处理方式的不同，所以在效率上的来讲，NIO效率会比IO效率高出很多。\n2. NIO不在是和IO一样用OutputStream和InputStream 输入流的形式来进行处理数据的，但是又是基于这种流的形式，为所有的原始类型提供Buffer缓存支持和新增Channel通道对象支持来进行处理数据。\n3. NIO的通道是双向的，既可读又可写，而IO中的流只能是单向的。\n4. NIO提供了基于Selector的异步网络I/O，即是多路复用的IO模型，而普通的IO用的是阻塞的IO模型，效率方面多路复用效率更高\n\n### 两点特性\n\n1. 新增Java.nio.charset.Charset作为字符集编码解码解决方案\n2. 支持锁和内存映射文件的文件访问接口\n\n## 最重要的两个组件：通道Channel和缓冲Buffer\n### 通道Channel\n1. 通道是对原 I/O 包中的流的模拟。到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象(通道)。Channel是一个双向通道，既可读，又可写，拿来与原来的I/O相比，即类似于Stream流，但是Stream是单向的。\n2. 应用程序不能直接对Channel进行读写操作，必须通过Buffer。比如在读一个Channel的时候，需要将数据读到相应的Buffer，然后从Buffer中读取。在写操作时永远不会将字节直接写入通道中，而是将数据写入包含一个或者多个字节的缓冲区。\n\n### 缓冲Buffer\n1. 在NIO中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中，在写入数据时，它是写入到缓冲区中。任何时候访问 NIO 中的数据，都是将它放到缓冲区中。\n2. 缓冲区实际上是一块连续的内存，是NIO读写数据的中转地。在代码上缓冲区实质上是一个数组，通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不仅仅是一个数组，它还提供了对数据的结构化访问，以及跟踪系统的读/写进程。\n3. 通道表示缓冲数据的源头或者目的地，用于向缓冲读取或者写入数据，是访问缓冲的接口，关系下图：\n               ![channel与buffer的关系](https://img-blog.csdnimg.cn/20200311163542755.png)\n### 使用实例\n- 下面是一个文件复制的例子，展示了NIO的基本使用操作\n\n```java\n// 1. 获取数据源和目标传输的输入输出流，此处用文件作为传输流\nFile source = new File(\"E:/study/test/source.txt\");\nFile target = new File(\"E:/study/test/target.txt\");\nFileInputStream fis = new FileInputStream(source);\nFileOutputStream fos = new FileOutputStream(target);\n// 2. 获取数据源的输入输出通道\nFileChannel fisc = fis.getChannel();\nFileChannel fosc = fos.getChannel();\n// 3. 创建缓冲区对象\n// 方法1：使用allocate()静态方法\nByteBuffer buffer = ByteBuffer.allocate(1024);\n// 上述方法创建1个容量为1024字节的ByteBuffer\n\n// 方法2：通过包装一个已有的数组来创建\n// 注：通过包装的方法创建的缓冲区保留了被包装数组内保存的数据\n// ByteBuffer buffer = ByteBuffer.wrap(new byte[1024]);\n\n// 额外：创建buffer时若需将1个字符串存入ByteBuffer，则如下\n// String sendstr = \"测试文字\";\n// ByteBuffer buffer = ByteBuffer.wrap(sendstr.getBytes(StandardCharsets.UTF_8));\n\nwhile (true){\n    // 4. 从通道读取数据 & 写入到缓冲区\n    // 注：若已读取到该通道数据的末尾，则返回-1\n    int read = fisc.read(buffer);\n    if (read == -1) {\n        break;\n    }\n\n    // 5. 传出数据准备：将缓存区的写模式 转换->> 读模式\n    buffer.flip();\n\n    // 6. 从Buffer中读取数据 & 传出数据到通道\n    fosc.write(buffer);\n\n    // 7. 重置缓冲区\n    // 目的：重用现在的缓冲区,即 不必为了每次读写都创建新的缓冲区，在再次读取之前要重置缓冲区\n    // 注：不会改变缓冲区的数据，只是重置缓冲区的主要索引值\n    buffer.clear();\n}\n// 关闭通道和流\nfosc.close();\nfisc.close();\nfos.close();\nfis.close();\nSystem.out.println(\"完成\");\n```\n\n## 底层工作原理（这里主要讲Buffer）\n### Buffer有三个重要参数，分别如下\n- 写模式\n1. position位置：当前缓冲区的位置，将从position的下一个位置写数据\n2. capactiy容量：缓冲区的总容量上限\n3. limit上限：缓冲区的实际上限，他总是小于或者等于容量\n- 读模式\n1. position位置：当前缓冲区读取的位置，将从此位置后，读取数据\n2. capactiy容量：缓冲区的总容量上限\n3. limit上限：代表可读取的总容量，和之前写入的数据量相等\n\n### 用一个使用buffer的例子讲解\n\n```java\nSystem.out.println(\"+++++++test begin+++++++\");\n// 创建一个15字节大小的缓冲区\nByteBuffer buffer = ByteBuffer.allocate(15);\nSystem.out.println(\"position=\" + buffer.position() + \",capacity=\" + buffer.capacity() + \",limit=\" + buffer.limit());\n// 放入10个字节数据\nfor (int i = 0; i < 10; i++) {\n    buffer.put((byte) i);\n}\nSystem.out.println(\"position=\" + buffer.position() + \",capacity=\" + buffer.capacity() + \",limit=\" + buffer.limit());\n// 重置position\nbuffer.flip();\nSystem.out.println(\"position=\" + buffer.position() + \",capacity=\" + buffer.capacity() + \",limit=\" + buffer.limit());\n// 取5个字节数据\nfor (int i = 0; i < 5; i++) {\n    System.out.print(buffer.get());\n}\nSystem.out.println(\"\\nposition=\" + buffer.position() + \",capacity=\" + buffer.capacity() + \",limit=\" + buffer.limit());\n// 重置position，剩余的5个字节数据会移动到0下标开始，读操作最多只能读到limit的位置，超过limit位置则会报错\nbuffer.flip();\nSystem.out.println(\"position=\" + buffer.position() + \",capacity=\" + buffer.capacity() + \",limit=\" + buffer.limit());\nSystem.out.println(\"+++++++test end+++++++\");\n```\n1. 首先分配15个字节的缓冲，p=0,c=15,l=15\n![](https://img-blog.csdnimg.cn/20200311172349615.png)\n2. 接着Buffer中被放入了10个byte，因此p向前移动，因为p位置指向当前缓冲区的位置，所以p=10,c和l不变\n![](https://img-blog.csdnimg.cn/20200311172544453.png)\n3. 接着执行flip()操作。该操作会重置p。通常，将Buffer从写模式转换为读模式时需要执行此方法。flip()操作不仅重置了当前的p=0，还将limit设置到p的位置，这样做是防止在读模式中，读到应用程序根本没有操作的区域\n![](https://img-blog.csdnimg.cn/20200311172813826.png)\n4. 接着执行5次读操作，和写操作一样，读操作也会设置p到当前位置\n![](https://img-blog.csdnimg.cn/20200311172902793.png)\n5. 最后执行flip(),p归零，limit设置到position的位置\n![](https://img-blog.csdnimg.cn/20200311172948342.png)\n### Buffer的相关操作\n1. 标志缓冲区：标志mark缓冲区是一项在数据处理时很有用的功能，它就像书签一样，在数据处理过程中，可以随时记录当前位置。在任意时刻，回到这个位置，从而加快和简化数据处理流程。主要方法为:\n- mark()：记录position的当前位置\n- reset()：恢复到mark所在的位置\n2. 重置和清空缓冲区\n- rewind()：将position置零，并清除标志位mark，它的作用在于为提取Buffer的有效数据做准备\n- clear()：将position置零，同时将limit设置为capacity的大小，并清除标志位mark。由于清除了limit，就无法得知Buffer内哪些数据是真实有效的，该方法用于为重新写Buffer做准备\n- flip()：先将limit设置到position的位置，然后将position置零，并清除标志位mark，用在读写转换时使用\n3. 读/写缓冲区：比如get()，put()等方法\n4. 复制缓冲区：以原缓冲区为基础，生成一个完全一样的新缓冲区，用duplicate()。这个函数主要用于处理复杂的Buffer数据，因为新生成的缓冲区和原缓冲共享相同的内存数据，并且一方的数据改动都相互可见，但两者又独立维护了各自的position、limit、mark，增加了灵活性\n5. 缓冲分片：slice()，在现有缓冲区中，创建新的子缓冲区，子缓冲区和父缓冲区共享数据。这个方法有助于将系统模块化。当需要处理一个Buffer的一个片段时，可以使用slice()方法获得一个子缓冲区，然后就像处理普通缓冲区一样处理，无需考虑缓冲区的边界问题\n6. 只读缓冲区：用asReadOnlyBuffer()方法得到一个与当前缓冲区一致的，并且共享内存数据的只读缓冲区。只读缓冲区对于数据安全非常有用，当缓冲区作为参数传递给某对象的某个方法时，由于无法确定该方法是否会破坏缓冲区的数据，此时，使用只读缓冲区可以保证数据不被修改。同时，因为只读缓冲区和原始缓冲区是共享内存块的，因此对原始缓冲区修改，只读缓冲区也同样可见\n7. 文件映射到内存：使用FileChannel.map()","tags":["Java基础","NIO"],"categories":["Java","IO"]},{"title":"SpringBoot 2.x 一个项目中使用RedisTemplate操作多个Redis库","url":"/2020/09/15/SpringBoot-2-x-一个项目中使用RedisTemplate操作多个Redis库/","content":"\n背景：我们都知道Redis有16个数据库可以使用，在项目中需要用到redis的多个库，每次使用时再去通过一堆代码切换未免觉得太过麻烦，所以直接通过配置注入多个RedisTemplate，需要用到哪个库时直接使用对应的RedisTemplate即可\n<!-- more -->\n\n### 首先是配置文件\n**在application.properties中添加redis的相关配置**\n\n```java\n#redis多数据配置\nredis.database.test1=1\nredis.database.test2=2\nredis.host=127.0.0.1\nredis.port=6379\nredis.password=root\n##连接超时，此处使用单位秒\nredis.timeout=180\n##连接池配置\nredis.pool.max-active=8\nredis.pool.max-idle=8\nredis.pool.min-idle=0\nredis.pool.max-wait=-1\n```\n- 数据库的选择可根据业务需求配置多个，此处测试只配置了两个。\n- 连接池的配置都是使用的默认值，如有其他需求可自行更改\n\n### 然后通过配置类注入RedisTemplate\n- 先看代码\n```java\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisPassword;\nimport org.springframework.data.redis.connection.RedisStandaloneConfiguration;\nimport org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;\nimport org.springframework.data.redis.connection.lettuce.LettucePoolingClientConfiguration;\nimport org.springframework.data.redis.core.StringRedisTemplate;\n\nimport java.time.Duration;\n\n/**\n * @date 2020/1/21\n */\n@Configuration\npublic class RedisConfiguration {\n\n    @Value(\"${redis.database.test1}\")\n    private int test1Database;\n\n    @Value(\"${redis.database.test2}\")\n    private int test2Database;\n\n    @Value(\"${redis.host}\")\n    private String host;\n\n    @Value(\"${redis.port}\")\n    private int port;\n\n    @Value(\"${redis.password}\")\n    private String password;\n\n    @Value(\"${redis.timeout}\")\n    private int timeout;\n\n    @Value(\"${redis.pool.max-active}\")\n    private int maxActive;\n\n    @Value(\"${redis.pool.max-idle}\")\n    private int maxIdle;\n\n    @Value(\"${redis.pool.min-idle}\")\n    private int minIdle;\n\n    @Value(\"${redis.pool.max-wait}\")\n    private int maxWait;\n\n    @Bean\n    public GenericObjectPoolConfig getPoolConfig(){\n        // 配置redis连接池\n        GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();\n        poolConfig.setMaxTotal(maxActive);\n        poolConfig.setMaxIdle(maxIdle);\n        poolConfig.setMinIdle(minIdle);\n        poolConfig.setMaxWaitMillis(maxWait);\n        return poolConfig;\n    }\n\n    @Bean(name = \"test1RedisTemplate\")\n    public StringRedisTemplate getTest1RedisTemplate(){\n        return getStringRedisTemplate(test1Database);\n    }\n\n    @Bean(name = \"test2RedisTemplate\")\n    public StringRedisTemplate getTest2RedisTemplate(){\n        // 构建工厂对象\n        return getStringRedisTemplate(test2Database);\n    }\n\n    private StringRedisTemplate getStringRedisTemplate(int database) {\n        // 构建工厂对象\n        RedisStandaloneConfiguration configuration = new RedisStandaloneConfiguration();\n        configuration.setHostName(host);\n        configuration.setPort(port);\n        configuration.setPassword(RedisPassword.of(password));\n        LettucePoolingClientConfiguration clientConfiguration = LettucePoolingClientConfiguration.builder()\n                .commandTimeout(Duration.ofSeconds(timeout)).poolConfig(getPoolConfig()).build();\n        LettuceConnectionFactory factory = new LettuceConnectionFactory(configuration, clientConfiguration);\n        // 设置使用的redis数据库\n        factory.setDatabase(database);\n        // 重新初始化工厂\n        factory.afterPropertiesSet();\n        return new StringRedisTemplate(factory);\n    }\n\n}\n```\n#### 解释几个地方：\n1. SpringBoot 2.x 之后连接redis驱动默认使用的是**lettuce**，而非之前的**jedis**，这里简要说一下两个驱动的区别：\n- jedis采用的是直连redis server，在多个线程之间共用一个jedis实例时，是线程不安全的。如果想避免线程不安全，可以使用连接池pool，这样每个线程单独使用一个jedis实例。由此带来的问题是，如果线程数过多，带来redis server的负载加大。有点类似于BIO的模式。\n\n- lettuce采用netty连接redis server，实例可以在多个线程间共享，不存在线程不安全的情况，这样可以减少线程数量。在特殊情况下，lettuce也可以使用多个实例。有点类似于NIO的模式\n\n2. 翻看源码**lettuce**驱动的连接池是依赖于apache的commons-pool2中的GenericObjectPoolConfig对象实现的，而SpringBoot对Redis的Starter中未引入该依赖\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n所以如果要配置连接池并且项目中未通过其他组件引入commons-pool2依赖时需要手动引入该依赖\n```java\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-pool2</artifactId>\n    <version>2.8.0</version>\n</dependency>\n```\n### 最后是测试环节\n- 直接使用SpringBoot的Junit测试，分别使用两个RedisTemplate操作Redis\n```java\n@SpringBootTest\nclass RedisdemoApplicationTests {\n\n    @Resource(name = \"test1RedisTemplate\")\n    private StringRedisTemplate test1RedisTemplate;\n\n    @Resource(name = \"test2RedisTemplate\")\n    private StringRedisTemplate test2RedisTemplate;\n\n    @Test\n    public void testRedisTemplate() {\n        // 测试用两个模板向redis中存值\n        test1RedisTemplate.opsForValue().set(\"name\", \"kong\");\n        test2RedisTemplate.opsForValue().set(\"age\", \"20\");\n    }\n\n}\n```\n- 查看Redis库看是否操作成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200122172854752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjIzMzUwMA==,size_16,color_FFFFFF,t_70)\n- 可以看到Redis两个库中均已存入相应的值，说明RedisTemplate生效\n\n> 至此项目中就实现了可以使用多个Redis库的操作\n","tags":["Java","Springboot","技术日常"],"categories":["Java","Springboot"]},{"title":"Springboot项目同时支持http和https访问","url":"/2020/09/15/Springboot项目同时支持http和https访问/","content":"\n因公司业务需求，需要项目同时支持http和https访问，在此记录如何实现\n项目采用springboot 2.x搭建，实现与springboot 1.x略有不同，使用springboot 2.x的可以参考实现\n<!-- more -->\n\n## 实现步骤：\n#### 1. 首先项目为sprintboot 2.x搭建，并引入web模块\n#### 2. 将https需要的证书放入项目中\n##### 2.1 证书来源\n- 如果公司提供，则直接使用公司提供的证书\n- 如果公司没有提供，也可自己使用Java自带的命令keytool来生成\n\t- windows下cmd打开命令黑窗口，输入以下命令（直接复制即可）\n\t```\n\tkeytool -genkey -alias tomcat  -storetype PKCS12 -keyalg RSA -keysize 2048  -keystore keystore.p12 -validity 3650\n\t```\n\t- 按照提示输入生成证书所需信息，就会在系统的当前用户目录下生成一个keystore.p12文件（如果你修改了证书文件的名称那就是你修改的名字）\n\t- 简单的参数说明：\n\t```\n\t1. -storetype 指定密钥仓库类型 \n\t2. -keyalg 生证书的算法名称，RSA是一种非对称加密算法 \n\t3. -keysize 证书大小 \n\t4. -keystore 生成的证书文件的存储路径 \n\t5. -validity 证书的有效期\n\t```\n\n##### 2.2 证书放置位置\n- 证书可以放在项目的根目录下，即和pom文件同级的目录\n- 证书也可放置在```src/main/resources```目录下\n- 两者放置位置不同配置时证书路径写法稍有不同，下文会具体说明\n\n#### 3. 在配置文件中配置支持https所需信息\n```properties\n# 支持https访问\n# https访问的端口号\nserver.port=8443\n# 证书的路径，根据证书放置位置不同，写法不同\n# 如果证书放在根目录下，此处只需要写证书的名字即可，但项目打包部署时提示证书找不到，故建议放在resources文件夹下\n# 如果证书放在 src/main/resources 下，则需写 classpath:keystore/server.keystore\nserver.ssl.key-store=classpath:keystore/server.keystore\n# 证书的签名密码，如果是自己生成的证书在输入信息时会有输入\nserver.ssl.key-store-password=slipper\n# 证书类型，常见的两种证书类型有：PKCS12和JKS，这里需要注意证书类型不能写错了，否则项目启动时会报错\nserver.ssl.keyStoreType=JKS\n```\n- 按照如上配置即可通过配置的8443端口实现https访问了\n- 例如：https://127.0.0.1:8443/...\n\n#### 4. 添加Java配置类使项目同时支持http访问\n- 因一个项目只能配置一个 ```server.port```，所以要支持http访问需要用Java代码实现\n\n4.1 配置文件中添加http端口配置\n```properties\nhttp.port=8060\n```\n4.2 书写Java配置类\n- 此处需要注意很多博客中提到的```EmbeddedServletContainerFactory```相关类，在springboot 2.x版本中已经被弃用，需要使用```WebServerFactoryCustomizer<ConfigurableWebServerFactory>```这种写法\n```java\n/**\n * \n * @function   http访问配置类\n *\n */\n@Configuration\npublic class TomcatConfig {\n    \n    @Value(\"${http.port}\")\n    private int httpPort;\n\n    @Bean\n    public WebServerFactoryCustomizer<ConfigurableWebServerFactory> webServerFactoryCustomizer() {\n        return new WebServerFactoryCustomizer<ConfigurableWebServerFactory>() {\n\n            @Override\n            public void customize(ConfigurableWebServerFactory factory) {\n                if (factory instanceof TomcatServletWebServerFactory) {\n                    TomcatServletWebServerFactory webServerFactory = (TomcatServletWebServerFactory)factory;\n                    Connector connector = new Connector(TomcatServletWebServerFactory.DEFAULT_PROTOCOL);\n                    // 设置http访问的端口号，不能与https端口重复，否则会报端口被占用的错误\n                    connector.setPort(httpPort);\n                    webServerFactory.addAdditionalTomcatConnectors(connector);\n                }\n            }\n        };\n    }\n      \n}\n```\n- 此时就可以使用8060端口http访问了\n- 例如：http://127.0.0.1:8060/...\n\n> 至此项目就实现了既能支持https访问，又能支持http访问\n\n- 参考资料：\n[springboot官方demo](https://github.com/spring-projects/spring-boot/blob/v2.0.0.RELEASE/spring-boot-samples/spring-boot-sample-tomcat-multi-connectors/src/main/java/sample/tomcat/multiconnector/SampleTomcatTwoConnectorsApplication.java)","tags":["Java","Springboot","技术日常"],"categories":["Java","Springboot"]}]