[{"title":"Java之NIO初探","url":"/2020/09/15/Java之NIO初探/","content":"\n这篇文章是学习了NIO之后的总结，结合了网上的博客和资料\n简述：在软件系统中，由于I/O的速度远比内存速度慢，所以I/O很容易成为系统的瓶颈。何为NIO，其实就是New IO的简称，与旧式基于流的I/O相对。\n<!-- more -->\n\n## NIO与IO的区别，NIO的特性\n1. NIO以块（Block）为基本单位处理数据，而IO是以最基础的字节流的形式去写入和读出。由于处理方式的不同，所以在效率上的来讲，NIO效率会比IO效率高出很多。\n2. NIO不在是和IO一样用OutputStream和InputStream 输入流的形式来进行处理数据的，但是又是基于这种流的形式，为所有的原始类型提供Buffer缓存支持和新增Channel通道对象支持来进行处理数据。\n3. NIO的通道是双向的，既可读又可写，而IO中的流只能是单向的。\n4. NIO提供了基于Selector的异步网络I/O，即是多路复用的IO模型，而普通的IO用的是阻塞的IO模型，效率方面多路复用效率更高\n### 两点特性\n1. 新增Java.nio.charset.Charset作为字符集编码解码解决方案\n2. 支持锁和内存映射文件的文件访问接口\n\n## 最重要的两个组件：通道Channel和缓冲Buffer\n### 通道Channel\n1. 通道是对原 I/O 包中的流的模拟。到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象(通道)。Channel是一个双向通道，既可读，又可写，拿来与原来的I/O相比，即类似于Stream流，但是Stream是单向的。\n2. 应用程序不能直接对Channel进行读写操作，必须通过Buffer。比如在读一个Channel的时候，需要将数据读到相应的Buffer，然后从Buffer中读取。在写操作时永远不会将字节直接写入通道中，而是将数据写入包含一个或者多个字节的缓冲区。\n\n### 缓冲Buffer\n1. 在NIO中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中，在写入数据时，它是写入到缓冲区中。任何时候访问 NIO 中的数据，都是将它放到缓冲区中。\n2. 缓冲区实际上是一块连续的内存，是NIO读写数据的中转地。在代码上缓冲区实质上是一个数组，通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不仅仅是一个数组，它还提供了对数据的结构化访问，以及跟踪系统的读/写进程。\n3. 通道表示缓冲数据的源头或者目的地，用于向缓冲读取或者写入数据，是访问缓冲的接口，关系下图：\n               ![channel与buffer的关系](https://img-blog.csdnimg.cn/20200311163542755.png)\n### 使用实例\n- 下面是一个文件复制的例子，展示了NIO的基本使用操作\n\n```java\n// 1. 获取数据源和目标传输的输入输出流，此处用文件作为传输流\nFile source = new File(\"E:/study/test/source.txt\");\nFile target = new File(\"E:/study/test/target.txt\");\nFileInputStream fis = new FileInputStream(source);\nFileOutputStream fos = new FileOutputStream(target);\n// 2. 获取数据源的输入输出通道\nFileChannel fisc = fis.getChannel();\nFileChannel fosc = fos.getChannel();\n// 3. 创建缓冲区对象\n// 方法1：使用allocate()静态方法\nByteBuffer buffer = ByteBuffer.allocate(1024);\n// 上述方法创建1个容量为1024字节的ByteBuffer\n\n// 方法2：通过包装一个已有的数组来创建\n// 注：通过包装的方法创建的缓冲区保留了被包装数组内保存的数据\n// ByteBuffer buffer = ByteBuffer.wrap(new byte[1024]);\n\n// 额外：创建buffer时若需将1个字符串存入ByteBuffer，则如下\n// String sendstr = \"测试文字\";\n// ByteBuffer buffer = ByteBuffer.wrap(sendstr.getBytes(StandardCharsets.UTF_8));\n\nwhile (true){\n    // 4. 从通道读取数据 & 写入到缓冲区\n    // 注：若已读取到该通道数据的末尾，则返回-1\n    int read = fisc.read(buffer);\n    if (read == -1) {\n        break;\n    }\n\n    // 5. 传出数据准备：将缓存区的写模式 转换->> 读模式\n    buffer.flip();\n\n    // 6. 从Buffer中读取数据 & 传出数据到通道\n    fosc.write(buffer);\n\n    // 7. 重置缓冲区\n    // 目的：重用现在的缓冲区,即 不必为了每次读写都创建新的缓冲区，在再次读取之前要重置缓冲区\n    // 注：不会改变缓冲区的数据，只是重置缓冲区的主要索引值\n    buffer.clear();\n}\n// 关闭通道和流\nfosc.close();\nfisc.close();\nfos.close();\nfis.close();\nSystem.out.println(\"完成\");\n```\n\n## 底层工作原理（这里主要讲Buffer）\n### Buffer有三个重要参数，分别如下\n- 写模式\n1. position位置：当前缓冲区的位置，将从position的下一个位置写数据\n2. capactiy容量：缓冲区的总容量上限\n3. limit上限：缓冲区的实际上限，他总是小于或者等于容量\n- 读模式\n1. position位置：当前缓冲区读取的位置，将从此位置后，读取数据\n2. capactiy容量：缓冲区的总容量上限\n3. limit上限：代表可读取的总容量，和之前写入的数据量相等\n\n### 用一个使用buffer的例子讲解\n\n```java\nSystem.out.println(\"+++++++test begin+++++++\");\n// 创建一个15字节大小的缓冲区\nByteBuffer buffer = ByteBuffer.allocate(15);\nSystem.out.println(\"position=\" + buffer.position() + \",capacity=\" + buffer.capacity() + \",limit=\" + buffer.limit());\n// 放入10个字节数据\nfor (int i = 0; i < 10; i++) {\n    buffer.put((byte) i);\n}\nSystem.out.println(\"position=\" + buffer.position() + \",capacity=\" + buffer.capacity() + \",limit=\" + buffer.limit());\n// 重置position\nbuffer.flip();\nSystem.out.println(\"position=\" + buffer.position() + \",capacity=\" + buffer.capacity() + \",limit=\" + buffer.limit());\n// 取5个字节数据\nfor (int i = 0; i < 5; i++) {\n    System.out.print(buffer.get());\n}\nSystem.out.println(\"\\nposition=\" + buffer.position() + \",capacity=\" + buffer.capacity() + \",limit=\" + buffer.limit());\n// 重置position，剩余的5个字节数据会移动到0下标开始，读操作最多只能读到limit的位置，超过limit位置则会报错\nbuffer.flip();\nSystem.out.println(\"position=\" + buffer.position() + \",capacity=\" + buffer.capacity() + \",limit=\" + buffer.limit());\nSystem.out.println(\"+++++++test end+++++++\");\n```\n1. 首先分配15个字节的缓冲，p=0,c=15,l=15\n![](https://img-blog.csdnimg.cn/20200311172349615.png)\n2. 接着Buffer中被放入了10个byte，因此p向前移动，因为p位置指向当前缓冲区的位置，所以p=10,c和l不变\n![](https://img-blog.csdnimg.cn/20200311172544453.png)\n3. 接着执行flip()操作。该操作会重置p。通常，将Buffer从写模式转换为读模式时需要执行此方法。flip()操作不仅重置了当前的p=0，还将limit设置到p的位置，这样做是防止在读模式中，读到应用程序根本没有操作的区域\n![](https://img-blog.csdnimg.cn/20200311172813826.png)\n4. 接着执行5次读操作，和写操作一样，读操作也会设置p到当前位置\n![](https://img-blog.csdnimg.cn/20200311172902793.png)\n5. 最后执行flip(),p归零，limit设置到position的位置\n![](https://img-blog.csdnimg.cn/20200311172948342.png)\n### Buffer的相关操作\n1. 标志缓冲区：标志mark缓冲区是一项在数据处理时很有用的功能，它就像书签一样，在数据处理过程中，可以随时记录当前位置。在任意时刻，回到这个位置，从而加快和简化数据处理流程。主要方法为:\n- mark()：记录position的当前位置\n- reset()：恢复到mark所在的位置\n2. 重置和清空缓冲区\n- rewind()：将position置零，并清除标志位mark，它的作用在于为提取Buffer的有效数据做准备\n- clear()：将position置零，同时将limit设置为capacity的大小，并清除标志位mark。由于清除了limit，就无法得知Buffer内哪些数据是真实有效的，该方法用于为重新写Buffer做准备\n- flip()：先将limit设置到position的位置，然后将position置零，并清除标志位mark，用在读写转换时使用\n3. 读/写缓冲区：比如get()，put()等方法\n4. 复制缓冲区：以原缓冲区为基础，生成一个完全一样的新缓冲区，用duplicate()。这个函数主要用于处理复杂的Buffer数据，因为新生成的缓冲区和原缓冲共享相同的内存数据，并且一方的数据改动都相互可见，但两者又独立维护了各自的position、limit、mark，增加了灵活性\n5. 缓冲分片：slice()，在现有缓冲区中，创建新的子缓冲区，子缓冲区和父缓冲区共享数据。这个方法有助于将系统模块化。当需要处理一个Buffer的一个片段时，可以使用slice()方法获得一个子缓冲区，然后就像处理普通缓冲区一样处理，无需考虑缓冲区的边界问题\n6. 只读缓冲区：用asReadOnlyBuffer()方法得到一个与当前缓冲区一致的，并且共享内存数据的只读缓冲区。只读缓冲区对于数据安全非常有用，当缓冲区作为参数传递给某对象的某个方法时，由于无法确定该方法是否会破坏缓冲区的数据，此时，使用只读缓冲区可以保证数据不被修改。同时，因为只读缓冲区和原始缓冲区是共享内存块的，因此对原始缓冲区修改，只读缓冲区也同样可见\n7. 文件映射到内存：使用FileChannel.map()","tags":["Java","NIO"],"categories":["Java","IO","Java基础"]},{"title":"SpringBoot 2.x 一个项目中使用RedisTemplate操作多个Redis库","url":"/2020/09/15/SpringBoot-2-x-一个项目中使用RedisTemplate操作多个Redis库/","content":"\n背景：我们都知道Redis有16个数据库可以使用，在项目中需要用到redis的多个库，每次使用时再去通过一堆代码切换未免觉得太过麻烦，所以直接通过配置注入多个RedisTemplate，需要用到哪个库时直接使用对应的RedisTemplate即可\n<!-- more -->\n\n### 首先是配置文件\n**在application.properties中添加redis的相关配置**\n\n```java\n#redis多数据配置\nredis.database.test1=1\nredis.database.test2=2\nredis.host=127.0.0.1\nredis.port=6379\nredis.password=root\n##连接超时，此处使用单位秒\nredis.timeout=180\n##连接池配置\nredis.pool.max-active=8\nredis.pool.max-idle=8\nredis.pool.min-idle=0\nredis.pool.max-wait=-1\n```\n- 数据库的选择可根据业务需求配置多个，此处测试只配置了两个。\n- 连接池的配置都是使用的默认值，如有其他需求可自行更改\n\n### 然后通过配置类注入RedisTemplate\n- 先看代码\n```java\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisPassword;\nimport org.springframework.data.redis.connection.RedisStandaloneConfiguration;\nimport org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;\nimport org.springframework.data.redis.connection.lettuce.LettucePoolingClientConfiguration;\nimport org.springframework.data.redis.core.StringRedisTemplate;\n\nimport java.time.Duration;\n\n/**\n * @date 2020/1/21\n */\n@Configuration\npublic class RedisConfiguration {\n\n    @Value(\"${redis.database.test1}\")\n    private int test1Database;\n\n    @Value(\"${redis.database.test2}\")\n    private int test2Database;\n\n    @Value(\"${redis.host}\")\n    private String host;\n\n    @Value(\"${redis.port}\")\n    private int port;\n\n    @Value(\"${redis.password}\")\n    private String password;\n\n    @Value(\"${redis.timeout}\")\n    private int timeout;\n\n    @Value(\"${redis.pool.max-active}\")\n    private int maxActive;\n\n    @Value(\"${redis.pool.max-idle}\")\n    private int maxIdle;\n\n    @Value(\"${redis.pool.min-idle}\")\n    private int minIdle;\n\n    @Value(\"${redis.pool.max-wait}\")\n    private int maxWait;\n\n    @Bean\n    public GenericObjectPoolConfig getPoolConfig(){\n        // 配置redis连接池\n        GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();\n        poolConfig.setMaxTotal(maxActive);\n        poolConfig.setMaxIdle(maxIdle);\n        poolConfig.setMinIdle(minIdle);\n        poolConfig.setMaxWaitMillis(maxWait);\n        return poolConfig;\n    }\n\n    @Bean(name = \"test1RedisTemplate\")\n    public StringRedisTemplate getTest1RedisTemplate(){\n        return getStringRedisTemplate(test1Database);\n    }\n\n    @Bean(name = \"test2RedisTemplate\")\n    public StringRedisTemplate getTest2RedisTemplate(){\n        // 构建工厂对象\n        return getStringRedisTemplate(test2Database);\n    }\n\n    private StringRedisTemplate getStringRedisTemplate(int database) {\n        // 构建工厂对象\n        RedisStandaloneConfiguration configuration = new RedisStandaloneConfiguration();\n        configuration.setHostName(host);\n        configuration.setPort(port);\n        configuration.setPassword(RedisPassword.of(password));\n        LettucePoolingClientConfiguration clientConfiguration = LettucePoolingClientConfiguration.builder()\n                .commandTimeout(Duration.ofSeconds(timeout)).poolConfig(getPoolConfig()).build();\n        LettuceConnectionFactory factory = new LettuceConnectionFactory(configuration, clientConfiguration);\n        // 设置使用的redis数据库\n        factory.setDatabase(database);\n        // 重新初始化工厂\n        factory.afterPropertiesSet();\n        return new StringRedisTemplate(factory);\n    }\n\n}\n```\n#### 解释几个地方：\n1. SpringBoot 2.x 之后连接redis驱动默认使用的是**lettuce**，而非之前的**jedis**，这里简要说一下两个驱动的区别：\n- jedis采用的是直连redis server，在多个线程之间共用一个jedis实例时，是线程不安全的。如果想避免线程不安全，可以使用连接池pool，这样每个线程单独使用一个jedis实例。由此带来的问题是，如果线程数过多，带来redis server的负载加大。有点类似于BIO的模式。\n\n- lettuce采用netty连接redis server，实例可以在多个线程间共享，不存在线程不安全的情况，这样可以减少线程数量。在特殊情况下，lettuce也可以使用多个实例。有点类似于NIO的模式\n\n2. 翻看源码**lettuce**驱动的连接池是依赖于apache的commons-pool2中的GenericObjectPoolConfig对象实现的，而SpringBoot对Redis的Starter中未引入该依赖\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n所以如果要配置连接池并且项目中未通过其他组件引入commons-pool2依赖时需要手动引入该依赖\n```java\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-pool2</artifactId>\n    <version>2.8.0</version>\n</dependency>\n```\n### 最后是测试环节\n- 直接使用SpringBoot的Junit测试，分别使用两个RedisTemplate操作Redis\n```java\n@SpringBootTest\nclass RedisdemoApplicationTests {\n\n    @Resource(name = \"test1RedisTemplate\")\n    private StringRedisTemplate test1RedisTemplate;\n\n    @Resource(name = \"test2RedisTemplate\")\n    private StringRedisTemplate test2RedisTemplate;\n\n    @Test\n    public void testRedisTemplate() {\n        // 测试用两个模板向redis中存值\n        test1RedisTemplate.opsForValue().set(\"name\", \"kong\");\n        test2RedisTemplate.opsForValue().set(\"age\", \"20\");\n    }\n\n}\n```\n- 查看Redis库看是否操作成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200122172854752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjIzMzUwMA==,size_16,color_FFFFFF,t_70)\n- 可以看到Redis两个库中均已存入相应的值，说明RedisTemplate生效\n\n> 至此项目中就实现了可以使用多个Redis库的操作\n","tags":["Java","Springboot"],"categories":["Java","Springboot","技术日常"]},{"title":"Springboot项目同时支持http和https访问","url":"/2020/09/15/Springboot项目同时支持http和https访问/","content":"\n因公司业务需求，需要项目同时支持http和https访问，在此记录如何实现\n项目采用springboot 2.x搭建，实现与springboot 1.x略有不同，使用springboot 2.x的可以参考实现\n<!-- more -->\n\n## 实现步骤：\n#### 1. 首先项目为sprintboot 2.x搭建，并引入web模块\n#### 2. 将https需要的证书放入项目中\n##### 2.1 证书来源\n- 如果公司提供，则直接使用公司提供的证书\n- 如果公司没有提供，也可自己使用Java自带的命令keytool来生成\n\t- windows下cmd打开命令黑窗口，输入以下命令（直接复制即可）\n\t```\n\tkeytool -genkey -alias tomcat  -storetype PKCS12 -keyalg RSA -keysize 2048  -keystore keystore.p12 -validity 3650\n\t```\n\t- 按照提示输入生成证书所需信息，就会在系统的当前用户目录下生成一个keystore.p12文件（如果你修改了证书文件的名称那就是你修改的名字）\n\t- 简单的参数说明：\n\t```\n\t1. -storetype 指定密钥仓库类型 \n\t2. -keyalg 生证书的算法名称，RSA是一种非对称加密算法 \n\t3. -keysize 证书大小 \n\t4. -keystore 生成的证书文件的存储路径 \n\t5. -validity 证书的有效期\n\t```\n\n##### 2.2 证书放置位置\n- 证书可以放在项目的根目录下，即和pom文件同级的目录\n- 证书也可放置在```src/main/resources```目录下\n- 两者放置位置不同配置时证书路径写法稍有不同，下文会具体说明\n\n#### 3. 在配置文件中配置支持https所需信息\n```properties\n# 支持https访问\n# https访问的端口号\nserver.port=8443\n# 证书的路径，根据证书放置位置不同，写法不同\n# 如果证书放在根目录下，此处只需要写证书的名字即可，但项目打包部署时提示证书找不到，故建议放在resources文件夹下\n# 如果证书放在 src/main/resources 下，则需写 classpath:keystore/server.keystore\nserver.ssl.key-store=classpath:keystore/server.keystore\n# 证书的签名密码，如果是自己生成的证书在输入信息时会有输入\nserver.ssl.key-store-password=slipper\n# 证书类型，常见的两种证书类型有：PKCS12和JKS，这里需要注意证书类型不能写错了，否则项目启动时会报错\nserver.ssl.keyStoreType=JKS\n```\n- 按照如上配置即可通过配置的8443端口实现https访问了\n- 例如：https://127.0.0.1:8443/...\n\n#### 4. 添加Java配置类使项目同时支持http访问\n- 因一个项目只能配置一个 ```server.port```，所以要支持http访问需要用Java代码实现\n\n4.1 配置文件中添加http端口配置\n```properties\nhttp.port=8060\n```\n4.2 书写Java配置类\n- 此处需要注意很多博客中提到的```EmbeddedServletContainerFactory```相关类，在springboot 2.x版本中已经被弃用，需要使用```WebServerFactoryCustomizer<ConfigurableWebServerFactory>```这种写法\n```java\n/**\n * \n * @function   http访问配置类\n *\n */\n@Configuration\npublic class TomcatConfig {\n    \n    @Value(\"${http.port}\")\n    private int httpPort;\n\n    @Bean\n    public WebServerFactoryCustomizer<ConfigurableWebServerFactory> webServerFactoryCustomizer() {\n        return new WebServerFactoryCustomizer<ConfigurableWebServerFactory>() {\n\n            @Override\n            public void customize(ConfigurableWebServerFactory factory) {\n                if (factory instanceof TomcatServletWebServerFactory) {\n                    TomcatServletWebServerFactory webServerFactory = (TomcatServletWebServerFactory)factory;\n                    Connector connector = new Connector(TomcatServletWebServerFactory.DEFAULT_PROTOCOL);\n                    // 设置http访问的端口号，不能与https端口重复，否则会报端口被占用的错误\n                    connector.setPort(httpPort);\n                    webServerFactory.addAdditionalTomcatConnectors(connector);\n                }\n            }\n        };\n    }\n      \n}\n```\n- 此时就可以使用8060端口http访问了\n- 例如：http://127.0.0.1:8060/...\n\n> 至此项目就实现了既能支持https访问，又能支持http访问\n\n- 参考资料：\n[springboot官方demo](https://github.com/spring-projects/spring-boot/blob/v2.0.0.RELEASE/spring-boot-samples/spring-boot-sample-tomcat-multi-connectors/src/main/java/sample/tomcat/multiconnector/SampleTomcatTwoConnectorsApplication.java)","tags":["Java","Springboot"],"categories":["Java","Springboot","技术日常"]}]